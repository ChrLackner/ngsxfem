#+TITLE: Approximation example with XFEM (incl. pde/python)
#+AUTHOR: Christoph Lehrenfeld
#+PROPERTY: header-args *python* :tangle yes :results output type: scalar format: org
#+email: christoph.lehrenfeld AT rwth-aachen DOT de
# COMMENT +INFOJS_OPT: toc:nil view:slide
#+OPTIONS: ^:nil
#+OPTIONS: tex:t  
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="media/style.css" />
-----
We explain a simple interface example.
* Description of the considered example
  We consider the solution of an interface problem.
  
  # We consider a domain $\Omega$ which is divided into two subdomains $\Omega_1$ 
  # and $\Omega_2$ by the interface $\Gamma$ which is only *implicitely* described.
  # On this domain we aim on solving the following $L^2(\Omega)$ - problem for $u_h \in V_h^\Gamma$:
  # \begin{equation}
  # \sum_{i=1,2} \int_{\Omega_i} u_h · v_h dx
  # = \sum_{i=1,2} \int_{\Omega_i} u   · v_h dx, \quad \forall v_h \in V_h^\Gamma
  # \end{equation}
  # with the (special) finite element space $V_h^\Gamma$. Next, we will explain how this is achieved 
  # in NGSolve/ngsxfem through the pde-file and how simple modifications can be achieved and 
  # additional information can be gathered by changes in the pde-file and additional functionality 
  # through python.
  
* Description and Explaination of the pde-file
** Geometry and mesh
   In the NGSolve pde-file the components for setting up the problem is defined. 
   First, a [[(geometry)][geometry]] and a [[(mesh)][mesh]] is loaded:
   #+NAME: mesh
   #+BEGIN_SRC pde +n -r
# load geometry
geometry = d2_xnitsche.in2d

# and mesh
mesh = d2_xnitsche.vol.gz
   #+END_SRC 
** Additional libraries
   Next, additional librarys are loaded. These are the [[(libngsxfem)][ngsxfem-library which adds XFEM-functionality]] 
   to NGSolve and [[(libngsxfempy)][a python module which transfers some of this functionality to python]]. 
   
   The line "[[(pymodd1)][pymodule = d1_approx]]" enforces loading of a small python module which adds a tiny 
   bit of additional functionality only for this test case written in python. The content of this 
   specific python module is discussed [[pymodule][later]].
   #+NAME: libs
   #+BEGIN_SRC pde +n -r
#load xfem-library
shared = libngsxfem_xfem                                       (ref:libngsxfem)
shared = libngsxfem_py                                       (ref:libngsxfempy)
pymodule = d1_approx                                              (ref:pymodd1)
   #+END_SRC 
** Constants, solutions and level set function
   Some simple constants are defined:
   #+NAME: const
   #+BEGIN_SRC pde +n -r

define constant heapsize = 1e8

# center of circle (domain 1)
define constant x0 = 0.1
define constant y0 = 0
   #+END_SRC 
   
   Now, we define a specific level set function which represents the interface as its zero level.
   Here, the interface is a simple circle with radius R (=0.4), i.e.
   \begin{equation}
   \phi(x) = \sqrt{x^2+y^2} - R
   \end{equation}
   #+NAME: lset
   #+BEGIN_SRC pde +n -r
# radius of circle (domain 1)
define constant R = 0.5

define coefficient lset
( sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)) - R),

numproc draw npd -coefficient=lset -label=levelset
   #+END_SRC 
   
   The reference solution is defined in order to prescribe suitable Dirichlet boundary conditions 
   and to evaluate errors later.
   \begin{equation}
   u(x) = \left\{\begin{array}{clc} 0.5&, & \text{in } \Omega_1 \\  sin(x^2+y^2-R^2)&, & \text{in } \Omega_2 \end{array} \right.
   \end{equation}
   #+NAME: sol
   #+BEGIN_SRC pde +n -r
# henry weights
define constant bneg = 3.0
define constant bpos = 4.0

define constant aneg = 0.3
define constant apos = 0.4

define coefficient rhspos
1,

define coefficient rhsneg
1,

define coefficient bndpos
0,

define coefficient bndneg
0,

define constant lambda = 2.0

define constant one = 1.0
   #+END_SRC 
** (Extended) Finite element space   
   We now want to define the finite element space to achieve the best approximation with.
   We create an instance of an [[(fescomptype)][extended 'standard' finite element space]] which is a compound
   space of a standard finite element space and the space of enrichment functions relative 
   to this space. 
   The underlying standard finite element space is defined with the [[(fesstdtype)][type_std]]-flag while other 
   parameters (e.g. [[(fesorder)][the order]]) of the FESpace are passed to that standard FESpace.
   The extended FESpace which is the second component of the compound space handles the enrichtment
   of the standard space and deals with the following information
  * a reference fespace (here: the underlying standard FESpace)
  * geometry information which consists of two parts:
    * a level set coefficient function
    * parameters for the approximation of the zero level of the level set function. This is done with 
      the flag [[(geometryref)][ref_space]] which prescribes how many levels of adaptive refinement
      on a local element are applied to resolve the zero level.
  * The [[(empty)][empty-flag]] can be used to *switch* the enrichment *off* while keeping the data structures
    for the geometry handling (essentially the composite numerical integration).
  #+NAME: xfespace
  #+BEGIN_SRC pde +n -r
define fespace fescomp                                            (ref:fescomp)
       -type=xstdfespace                                      (ref:fescomptype)
       -type_std=h1ho                                          (ref:fesstdtype)
       -order=1                                                  (ref:fesorder)
       -dirichlet=[1,2]                                         (ref:dirichlet)
       -ref_space=1                                           (ref:geometryref)
#       -empty                                                      (ref:empty)
#       -dgjumps
  #+END_SRC 
 
  At this point the XStdFESpace and especially the XFESpace has no information about the geometry as no 
  level set information is passed, yet. This is done externally with a [[(numprocinform)][numproc]] 
  which passes the information of the [[(passlset)][corresponding level set function]] to 
  the [[(passfes)][XStdFESpace]].
  #+NAME: numprocinform
  #+BEGIN_SRC pde +n -r
numproc informxfem npix
        -xstdfespace=fescomp
        -coef_levelset=lset
  #+END_SRC 

** Gridfunction, linear and bilinear forms  
  #+NAME: comp
  #+BEGIN_SRC pde +n -r

define gridfunction u -fespace=fescomp

define linearform f -fespace=fescomp
xsource rhsneg rhspos

define bilinearform a -fespace=fescomp -symmetric -linearform=f
xlaplace aneg*bneg apos*bpos
xnitsche_hansbo aneg apos bneg bpos lambda
# xnitsche_minstab_hansbo aneg apos bneg bpos
#lo_ghostpenalty aneg apos one

numproc setvaluesx npsvx -gridfunction=u -coefficient_neg=bndneg -coefficient_pos=bndpos -boundary #-print
  #+END_SRC 

** Solver   
  #+NAME: bvp
  #+BEGIN_SRC pde +n -r
#define preconditioner c -type=local -bilinearform=a -test #-block
define preconditioner c -type=direct -bilinearform=a -inverse=pardiso #-test
#define preconditioner c -type=bddc -bilinearform=a -test -block
#define preconditioner c -type=multigrid -bilinearform=a -test #-smoother=block

numproc bvp npbvp -gridfunction=u -bilinearform=a -linearform=f -solver=cg -preconditioner=c -maxsteps=1000 -prec=1e-6 
  #+END_SRC 

** Visualization
  #+NAME: xvis
  #+BEGIN_SRC pde +n -r
numproc visualization npviz -scalarfunction=u 
    -minval=0 -maxval=0.3
    -nolineartexture -deformationscale=1 -subdivision=4
  #+END_SRC 

** Things to try with the pde-file here:
 1) ...
 2) ...

* Additional investigations with python    
** Simple python start-off
   At the beginning we briefly announce ourselves with a friendly "hello":
   #+NAME: start
   #+BEGIN_SRC python -n -r :exports both
   # interactive modifications to d2_xnitsche.py
   print ("hello from d2_xnitsche.py ;-)")
   #+END_SRC
   
   which simply results in:
   #+RESULTS: start
   
** Import ngsolve and xfem functionality to python <<pymodule>>
   Then we import a lot of functionality from ngsolve and ngsxfem.
   #+NAME: imports
   #+BEGIN_SRC python +n -r
   from ngsolve.solve import *
   from ngsolve.comp import *
   from ngsolve.fem import *
   from ngsolve.la import *
   from ngsolve.bla import *
   import ngsolve.ngstd as ngstd
   from ngsolve.solve import Redraw

   #from libngsxfem_py.xfem import *
   import libngsxfem_py.xfem as xfem                                 (ref:libxfem)

   from math import sin                                                  (ref:sin)
   from time import sleep                                              (ref:sleep)
   #+END_SRC
   We included the command [[(sin)][sin]] for no reason.
   We included the command [[(sleep)][sleep]] to pause between the individual shape functions.
   
** Small functions for inspections:
   ... minor explanation ... 
*** Print dofs per elements:
    #+NAME: printdofs
    #+BEGIN_SRC python +n -r
   def PrintDofs(pde,mesh,fes):
       print ("Printing dofs per element:\n\n")
       for i in mesh.Elements():
           print("dofnrs of element", i, ":\n", fes.GetDofNrs(i))
    #+END_SRC
    
*** Show shape functions
    Every (extended) finite element function can be represented as
    \begin{equation}
    u = \sum_{i=1}^{N} u_i \phi(x) + \sum_{i=1}^{N_x} u_i^x \phi^x(x).
    \end{equation}
    By setting the coefficients $u_i$, $u_i^x$ [[(setzero)][to zero]] and only [[(shapefct)][one coefficient to 1]], we can construct
    $u = \phi(x)$ or $u = \phi^x(x)$. We do this for [[(eachshp)][every shape function]] 
    and call a [[(redraw)][Redraw]] and a [[(slp)][short delay]] between the functions.
    #+NAME: shapetest
    #+BEGIN_SRC python +n -r
   def ShapeTest(pde,u):
       print ("Shape test:\n")
       u[:][:] = 0                                                   (ref:setzero)
       for i in range(u.size):                                       (ref:eachshp)
           print ("i = ", i ,".")
           u[:][i-1] = 0.0
           u[:][i] = 1.0                                            (ref:shapefct)
           Redraw(blocking=True)                                      (ref:redraw)
           sleep(1)                                                      (ref:slp)
    #+END_SRC
    
** Put everything together
   #+NAME: test
   #+BEGIN_SRC python +n -r
   def Test(pde):
       PrintDofs(pde,pde.Mesh(),pde.spaces["fescomp"].StdFESpace)
       PrintDofs(pde,pde.Mesh(),pde.spaces["fescomp"].XFESpace)
       ShapeTest(pde,pde.gridfunctions["u"].vec)
   #+END_SRC
   
* Resulting files
  * [[file:d2_xnitsche.pde][d2_xnitsche.pde]]
  * [[file:d2_xnitsche.py][d2_xnitsche.py]] 
    
  #+RESULTS:
  
  
  
