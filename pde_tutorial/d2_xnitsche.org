#+TITLE: Interface problem with XFEM (incl. pde/python)
#+AUTHOR: Christoph Lehrenfeld
#+PROPERTY: header-args *python* :tangle yes :results output type: scalar format: org
#+email: christoph.lehrenfeld AT rwth-aachen DOT de
# COMMENT +INFOJS_OPT: toc:nil view:slide
#+OPTIONS: ^:nil
#+OPTIONS: tex:t  
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="media/style.css" />
-----

This document is under construction ...

We explain a simple interface example.
* Description of the considered example
  We consider the solution of an interface problem.
  
  # We consider a domain $\Omega$ which is divided into two subdomains $\Omega_1$ 
  # and $\Omega_2$ by the interface $\Gamma$ which is only *implicitely* described.
  # On this domain we aim on solving the following $L^2(\Omega)$ - problem for $u_h \in V_h^\Gamma$:
  # \begin{equation}
  # \sum_{i=1,2} \int_{\Omega_i} u_h · v_h dx
  # = \sum_{i=1,2} \int_{\Omega_i} u   · v_h dx, \quad \forall v_h \in V_h^\Gamma
  # \end{equation}
  # with the (special) finite element space $V_h^\Gamma$. Next, we will explain how this is achieved 
  # in NGSolve/ngsxfem through the pde-file and how simple modifications can be achieved and 
  # additional information can be gathered by changes in the pde-file and additional functionality 
  # through python.
  
* Description and Explaination of the pde-file
Many things are very similar to the example [[file:d1_approx.pde][d2_approx.pde]]. We thus only discuss new aspects. 

** Geometry, mesh and libraries
   In the NGSolve pde-file the components for setting up the problem is defined. 
   First, a geometry and a mesh is loaded. Afterwards additional libraries are loaded.
   #+NAME: mesh
   #+BEGIN_SRC pde +n -r
# load geometry
geometry = d2_xnitsche.in2d

# and mesh
mesh = d2_xnitsche.vol.gz

#load xfem-library
shared = libngsxfem_xfem                                    
shared = libngsxfem_py                                      
pymodule = d1_approx                                        
   #+END_SRC 
** Constants, solutions and level set function
   Some simple constants are defined:
   #+NAME: const
   #+BEGIN_SRC pde +n -r

define constant heapsize = 1e8

# center of circle (domain 1)
define constant x0 = 0.1
define constant y0 = 0
   #+END_SRC 
   
   Now, we define a specific level set function which represents the interface as its zero level.
   Here, the interface is a simple circle with radius R (=0.4), i.e.
   \begin{equation}
   \phi(x) = \sqrt{x^2+y^2} - R
   \end{equation}
   #+NAME: lset
   #+BEGIN_SRC pde +n -r
# radius of circle (domain 1)
define constant R = 0.5

define coefficient lset
( sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)) - R),

numproc draw npd -coefficient=lset -label=levelset
   #+END_SRC 
   
   The reference solution is defined in order to prescribe suitable Dirichlet boundary conditions 
   and to evaluate errors later.
   \begin{equation}
   u(x) = \left\{\begin{array}{clc} 0.5&, & \text{in } \Omega_1 \\  sin(x^2+y^2-R^2)&, & \text{in } \Omega_2 \end{array} \right.
   \end{equation}
   #+NAME: sol
   #+BEGIN_SRC pde +n -r
# henry weights
define constant bneg = 3.0
define constant bpos = 4.0

define constant aneg = 0.3
define constant apos = 0.4

define coefficient rhspos
1,

define coefficient rhsneg
1,

define coefficient bndpos
0,

define coefficient bndneg
0,

define constant lambda = 2.0

define constant one = 1.0
   #+END_SRC 
** (Extended) Finite element space and Gridfunction   
   For the extended finite element space we now also discuss two flags which exist for every finite element space in NGSolve:
  * The [[(dirichlet)][dirichlet-flags]] mark degrees of freedom at selected boundaries as 'known' and implements values as essential conditions
  * The [[(dgjumps)][dgjumps-flag]] adds additional couplings into the matrix pattern for the discretization. This might become necessary for methods which 
    involve integrals at element interfaces. In the context of extended finite elements this can be stabilization terms, e.g. the ghost penalty integrals. 
  #+NAME: xfespace
  #+BEGIN_SRC pde +n -r
define fespace fescomp                                            (ref:fescomp)
       -type=xstdfespace                                      (ref:fescomptype)
       -type_std=h1ho                                          (ref:fesstdtype)
       -order=1                                                  (ref:fesorder)
       -dirichlet=[1,2]                                         (ref:dirichlet)
       -ref_space=1                                           (ref:geometryref)
#       -empty                                                      (ref:empty)
#       -dgjumps                                                  (ref:dgjumps)

numproc informxfem npix
        -xstdfespace=fescomp
        -coef_levelset=lset
  #+END_SRC 

** Gridfunction, linear and bilinear forms  
   The treatment of gridfunctions and linear forms is the same as before.
  #+NAME: comp1
  #+BEGIN_SRC pde +n -r

define gridfunction u -fespace=fescomp

define linearform f -fespace=fescomp
xsource rhsneg rhspos

  #+END_SRC 
   For the bilinearform, we consider new integrators, such as
   * The [[(laplace)][xlaplace-integrator]] which is a broken laplace-integrator w.r.t. the two domains
   * The [[(xnitsche)][xnitsche-integrator]] which implements the interface condition in a weak sense
   * ( [[(xnitscheminstab)][a variant of the default nitsche-formulation]] )
   * ( An [[(loghostpenalty)][additional stabilization]] bilinear form )
  #+NAME: comp2
  #+BEGIN_SRC pde +n -r
define bilinearform a -fespace=fescomp -symmetric -linearform=f
xlaplace aneg*bneg apos*bpos                                    (ref:laplace)
xnitsche_hansbo aneg apos bneg bpos lambda                     (ref:xnitsche)
# xnitsche_minstab_hansbo aneg apos bneg bpos           (ref:xnitscheminstab)
#lo_ghostpenalty aneg apos one                           (ref:loghostpenalty)

  #+END_SRC 
Setting boundary conditions in extended finite elements is slightly different from the methods used for 
standard finite element spaces. The corresponding function [[(setvaluesx)][setvaluesx]] needs two 
functions defined at the boundary corresponding to the restriction of the boundary to domain one (neg) 
and domain two (pos). 
  #+NAME: comp3
  #+BEGIN_SRC pde +n -r
numproc setvaluesx npsvx -gridfunction=u -coefficient_neg=bndneg -coefficient_pos=bndpos -boundary (ref:setvaluesx)

  #+END_SRC 

** Solver and Visualization
   As before:
  #+NAME: bvp
  #+BEGIN_SRC pde +n -r
#define preconditioner c -type=local -bilinearform=a -test #-block
define preconditioner c -type=direct -bilinearform=a -inverse=pardiso #-test

numproc bvp npbvp -gridfunction=u -bilinearform=a -linearform=f -solver=cg -preconditioner=c -maxsteps=1000 -prec=1e-6 

numproc visualization npviz -scalarfunction=u 
    -minval=0 -maxval=0.3
    -nolineartexture -deformationscale=1 -subdivision=4
  #+END_SRC 

** Things to try with the pde-file here:
 1) ...
 2) ...

* Resulting files
  * [[file:d2_xnitsche.pde][d2_xnitsche.pde]]
    
  #+RESULTS:
  
  
  
