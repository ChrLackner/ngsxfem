#+TITLE: Approximation example with XFEM (incl. pde/python)
#+AUTHOR: Christoph Lehrenfeld
#+PROPERTY: header-args *python* :tangle yes :results output type: scalar format: org
#+email: christoph.lehrenfeld AT rwth-aachen DOT de
# COMMENT +INFOJS_OPT: toc:nil view:slide
#+OPTIONS: ^:nil
#+OPTIONS: tex:t  
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="media/style.css" />
-----
We explain a simple approximation example.
* Description of the considered example
  We consider an L2-approximation problem of a domain-wise smooth function which is 
  discontinuous across an implicitly prescribed interface.
  
  We consider a domain $\Omega$ which is divided into two subdomains $\Omega_1$ 
  and $\Omega_2$ by the interface $\Gamma$ which is only *implicitely* described.
  On this domain we aim on solving the following $L^2(\Omega)$ - problem for $u_h \in V_h^\Gamma$:
  \begin{equation}
  \sum_{i=1,2} \int_{\Omega_i} u_h · v_h dx
  = \sum_{i=1,2} \int_{\Omega_i} u   · v_h dx, \quad \forall v_h \in V_h^\Gamma
  \end{equation}
  with the (special) finite element space $V_h^\Gamma$. Next, we will explain how this is achieved 
  in NGSolve/ngsxfem through the pde-file and how simple modifications can be achieved and 
  additional information can be gathered by changes in the pde-file and additional functionality 
  through python.
  
* Description and Explanation of the pde-file
** Geometry and mesh
   In the NGSolve pde-file the components for setting up the problem is defined. 
   First, a [[(geometry)][geometry]] and a [[(mesh)][mesh]] is loaded:
   #+NAME: mesh
   #+BEGIN_SRC pde +n -r
  # load geometry
  geometry = d1_approx.in2d                                        (ref:geometry)
  # and mesh
  mesh = d1_approx.vol.gz                                              (ref:mesh)
   #+END_SRC 
** Additional libraries
   Next, additional librarys are loaded. These are the [[(libngsxfem)][ngsxfem-library which adds XFEM-functionality]] 
   to NGSolve and [[(libngsxfempy)][a python module which transfers some of this functionality to python]]. 
   
   The line "[[(pymodd1)][pymodule = d1_approx]]" enforces loading of a small python module which adds a tiny 
   bit of additional functionality only for this test case written in python. The content of this 
   specific python module is discussed [[pymodule][later]].
   #+NAME: libs
   #+BEGIN_SRC pde +n -r
  #load xfem-library and python-bindings
  shared = libngsxfem_xfem                                       (ref:libngsxfem)
  shared = libngsxfem_py                                       (ref:libngsxfempy)
  pymodule = d1_approx                                              (ref:pymodd1)
   #+END_SRC 
** Constants, solutions and level set function
   Some simple constants are defined:
   #+NAME: const
   #+BEGIN_SRC pde +n -r
define constant heapsize = 1e9

define constant R = 0.4
define constant one = 1.0
   #+END_SRC 
   
   Now, we define a specific level set function which represents the interface as its zero level.
   Here, the interface is a simple circle with radius R (=0.4), i.e.
   \begin{equation}
   \phi(x) = \sqrt{x^2+y^2} - R
   \end{equation}
   #+NAME: lset
   #+BEGIN_SRC pde +n -r
# interface description as zero-level
define coefficient lset
( sqrt(x*x+y*y) - R),       
   #+END_SRC 
   
   The right hand side term $u$ (which is at the same time the reference solution) is defined.
   $u$ is needed for the setup of the r.h.s.,  in order to prescribe suitable Dirichlet boundary conditions 
   and to evaluate errors later. Here, we choose
   \begin{equation}
   u(x) = \left\{\begin{array}{clc} 0.5&, & \text{in } \Omega_1 \\  sin(x^2+y^2-R^2)&, & \text{in } \Omega_2 \end{array} \right.
   \end{equation}
   #+NAME: sol
   #+BEGIN_SRC pde +n -r
# solution u- in 'inner' domain (Omega_1)
define coefficient solneg
0.5,

# solution u+ in 'outer' domain (Omega_2)
define coefficient solpos
(sin((x*x+y*y-R*R))),
   #+END_SRC 
** (Extended) Finite element space   
   We now want to define the finite element space to achieve the best approximation with.
   We create an instance of an [[(fescomptype)][extended 'standard' finite element space]] which is a compound
   space of a standard finite element space and the space of enrichment functions relative 
   to this space. 
   The underlying standard finite element space is defined with the [[(fesstdtype)][type_std]]-flag while other 
   parameters (e.g. [[(fesorder)][the order]]) of the FESpace are passed to that standard FESpace.
   The extended FESpace which is the second component of the compound space handles the enrichtment
   of the standard space and deals with the following information
  * a reference fespace (here: the underlying continuous FESpace)
  * geometry information which consists of two parts:
    * a level set coefficient function
    * parameters for the approximation of the zero level of the level set function. This is done with 
      the flag [[(geometryref)][ref_space]] which prescribes how many levels of adaptive refinement
      on a local element are applied to resolve the zero level.
  * The [[(empty)][empty-flag]] can be used to *switch* the enrichment *off* while keeping the data structures
    for the geometry handling (essentially the composite numerical integration).
  #+NAME: xfespace
  #+BEGIN_SRC pde +n -r
  # use an "extended" continuous finite element space
  # you may change the order here
  define fespace fescomp                                            (ref:fescomp)
         -type=xstdfespace                                      (ref:fescomptype)
         -type_std=h1ho                                          (ref:fesstdtype)
         -order=1                                                  (ref:fesorder)
         -ref_space=1                                           (ref:geometryref)
  #       -empty                                                      (ref:empty)
  #+END_SRC 
  Alternatively one could use a discontinuous finite element space as the underlying 
  'standard' finite element space. To this end, replace the last code block with something
  like
  #+NAME: xfespacealt
  #+BEGIN_SRC pde -r :tangle no
  define fespace fescomp  
         -type=xstdfespace
         -type_std=l2ho   
         -order=0         
         -ref_space=1     
  #+END_SRC 
  
  At this point the XStdFESpace and especially the XFESpace has no information about the geometry as no 
  level set information is passed, yet. This is done externally with a [[(numprocinform)][numproc]] 
  which passes the information of the [[(passlset)][corresponding level set function]] to 
  the [[(passfes)][XStdFESpace]].
  #+NAME: numprocinform
  #+BEGIN_SRC pde +n -r
  #update "extended" part of XFE space:
  numproc informxfem npix                                     (ref:numprocinform)
          -xstdfespace=fescomp                                      (ref:passfes)
          -coef_levelset=lset                                      (ref:passlset)
  #+END_SRC 

** Gridfunction, linear and bilinear forms  
Now we create a gridfunction for the solution vector 
and define the bi- and linear forms for the matrix and the r.h.s. vector for the 
discrete problem. Special integrators suitable for the extended finite element space
are used, [[(xsource)][xsource]] and [[(xmass)][xmass]]. Both take two coefficient functions
as arguments. One cofficient function for each domain. Note that the problem is symmetric.
  #+NAME: comp
  #+BEGIN_SRC pde +n -r
define gridfunction u -fespace=fescomp

# integration on sub domains
define linearform f -fespace=fescomp
xsource solneg solpos                             (ref:xsource)

# integration on sub domains
define bilinearform a -fespace=fescomp -symmetric -linearform=f
xmass 1.0 1.0                                       (ref:xmass)
  #+END_SRC 

** Solver  
To solve the arising linear system we use [[(direct)][direct solver]] as a preconditioner. Alternatively, one could also use the
[[(jacobi)][Jacobi-preconditioner]]. Then, the problem is solved and the solution is stored in the gridfunction u.
  #+NAME: bvp
  #+BEGIN_SRC pde +n -r
#define preconditioner c -type=local -bilinearform=a -test #-block           (ref:jacobi)
define preconditioner c -type=direct -bilinearform=a -inverse=pardiso #-test (ref:direct)

numproc bvp npbvp -gridfunction=u -bilinearform=a -linearform=f -solver=cg -preconditioner=c -maxsteps=1000 -prec=1e-6 
  #+END_SRC 
  
** Visualization
The solution is visualized. 
  #+NAME: xvis
  #+BEGIN_SRC pde +n -r
numproc visualization npviz -scalarfunction=u 
    -minval=0 -maxval=1 
    -nolineartexture -deformationscale=1 -subdivision=4
  #+END_SRC 
  
** Error calculatoin
Finally, the error $u_h$ (discrete solution) to $u$ is calculated via numerical integration. 
  #+NAME: xdiff
  #+BEGIN_SRC pde +n -r
# evaluate l2-error (difference between prescribed solution and numerical solution)
numproc xdifference npxd 
        -solution=u 
        -solution_n=solneg
        -solution_p=solpos
        -intorder=3
  #+END_SRC
After reading the explanation, start netgen and inspect the result of the simulation. 
In the next section a few small tasks are suggested to investigate some important properties
of the XFEM discretization.
** Things to try with the pde-file here:
 1) Add the following line, reload the pde-file, invoke solve and navigate through
    the shape functions with the GUI:
  #+BEGIN_SRC pde -r :tangle no
numproc shapetester npst -gridfunction=u
  #+END_SRC 
    To see all shape functions make sure that subdivisions are at least 3 and disable automatic 
    scaling. Instead use minval=0 and maxval=1. Afterwards remove the line again
 2) Refine the mesh and observe the convergence order. Note that different error calculations 
    are printed. Not all of them are meaningful (e.g. the interface measures). We are primarily 
    interested in the $L^2$-error.
 3) Set flag "empty" (this removes the enrichted functions)
    for xstdfespace, refine the mesh and observe the 
    convergence order (L2). Afterwards remove "empty" again.
 4) Set "order" to 2 and try 1) - 3) again, make sure to 
    increase "ref_space" in xstdfespace and "intorder" in 
    xdifference
 5) set "order" back to 1, set the preconditioner to "local" 
    and add the "-test"-flags, refine the mesh several times
    and observe the performance
 6) set "order" to 2 and try 5) again

* Additional investigations with python  
Some interesting information can be read from python through the corresponding interface. 
A very small introduction is given here. These things result in the python script [[file:d1_approx.py][d1_approx.py]].
** Simple python start-off
   At the beginning we briefly announce ourselves with a friendly "hello":
   #+NAME: start
   #+BEGIN_SRC python -n -r :exports both
   # interactive modifications to d1_approx.py
   print ("hello from d1_approx.py ;-)")
   #+END_SRC
   
   which simply results in:
   #+RESULTS: start
   
** Import ngsolve and xfem functionality to python <<pymodule>>
   Then we import a lot of functionality from ngsolve and ngsxfem.
   #+NAME: imports
   #+BEGIN_SRC python +n -r
   from ngsolve.solve import *
   from ngsolve.comp import *
   from ngsolve.fem import *
   from ngsolve.la import *
   from ngsolve.bla import *
   import ngsolve.ngstd as ngstd
   from ngsolve.solve import Redraw

   #from libngsxfem_py.xfem import *
   import libngsxfem_py.xfem as xfem                                 (ref:libxfem)

   from math import sin                                                  (ref:sin)
   from time import sleep                                              (ref:sleep)
   #+END_SRC
   We included the command [[(sin)][sin]] for no reason.
   We included the command [[(sleep)][sleep]] to pause between the individual shape functions.
   
** Small functions for inspections:
   We use some really basic things, e.g. reading the d.o.f. of a triangle or fixing the solution vector. 
*** Print dofs per elements:
    We simply display the degrees of freedom for each element when "PrintDofs" is called.
    #+NAME: printdofs
    #+BEGIN_SRC python +n -r
   def PrintDofs(pde,mesh,fes):
       print ("Printing dofs per element:\n\n")
       for i in mesh.Elements():
           print("dofnrs of element", i, ":\n", fes.GetDofNrs(i))
    #+END_SRC
    
*** Show shape functions
    Every (extended) finite element function can be represented as
    \begin{equation}
    u = \sum_{i=1}^{N} u_i \phi(x) + \sum_{i=1}^{N_x} u_i^x \phi^x(x).
    \end{equation}
    By setting the coefficients $u_i$, $u_i^x$ [[(setzero)][to zero]] and only [[(shapefct)][one coefficient to 1]], we can construct
    $u = \phi(x)$ or $u = \phi^x(x)$. We do this for [[(eachshp)][every shape function]] 
    and call a [[(redraw)][Redraw]] and a [[(slp)][short delay]] between the functions.
    #+NAME: shapetest
    #+BEGIN_SRC python +n -r
   def ShapeTest(pde,u):
       print ("Shape test:\n")
       u[:][:] = 0                                                   (ref:setzero)
       for i in range(u.size):                                       (ref:eachshp)
           print ("i = ", i ,".")
           u[:][i-1] = 0.0
           u[:][i] = 1.0                                            (ref:shapefct)
           Redraw(blocking=True)                                      (ref:redraw)
           sleep(1)                                                      (ref:slp)
    #+END_SRC
    
** Put everything together
   Call the previously explained mini-functions:
   #+NAME: test
   #+BEGIN_SRC python +n -r
   def Test(pde):
       PrintDofs(pde,pde.Mesh(),pde.spaces["fescomp"].StdFESpace)
       PrintDofs(pde,pde.Mesh(),pde.spaces["fescomp"].XFESpace)
       ShapeTest(pde,pde.gridfunctions["u"].vec)
   #+END_SRC
   
* Resulting files
  * [[file:d1_approx.pde][d1_approx.pde]]
  * [[file:d1_approx.py][d1_approx.py]] 
    
  #+RESULTS:
  
  
  
